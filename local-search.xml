<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>北京DeepLang后端暑期实习一面</title>
    <link href="/2024/06/24/%E5%8C%97%E4%BA%ACDeepLang%E5%90%8E%E7%AB%AF%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2/"/>
    <url>/2024/06/24/%E5%8C%97%E4%BA%ACDeepLang%E5%90%8E%E7%AB%AF%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="北京DeepLang（北京深言科技）后端实习一面"><a href="#北京DeepLang（北京深言科技）后端实习一面" class="headerlink" title="北京DeepLang（北京深言科技）后端实习一面"></a>北京<code>DeepLang</code>（北京深言科技）后端实习一面</h2><h3 id="记录一下自己读研一来的第一场面试，结果就是：被薄纱😭😭。面试官是前字节跳动三年工作经历者，这正好跟我的字节跳动青训营项目撞上了，因此被疯狂询问底层原理机制，还包括Redis、Mysql等底层实现。具体面试内容如下："><a href="#记录一下自己读研一来的第一场面试，结果就是：被薄纱😭😭。面试官是前字节跳动三年工作经历者，这正好跟我的字节跳动青训营项目撞上了，因此被疯狂询问底层原理机制，还包括Redis、Mysql等底层实现。具体面试内容如下：" class="headerlink" title="记录一下自己读研一来的第一场面试，结果就是：被薄纱😭😭。面试官是前字节跳动三年工作经历者，这正好跟我的字节跳动青训营项目撞上了，因此被疯狂询问底层原理机制，还包括Redis、Mysql等底层实现。具体面试内容如下："></a>记录一下自己读研一来的第一场面试，结果就是：被薄纱😭😭。面试官是前字节跳动三年工作经历者，这正好跟我的字节跳动青训营项目撞上了，因此被疯狂询问底层原理机制，还包括<code>Redis、Mysql</code>等底层实现。具体面试内容如下：</h3><h5 id="1、自我介绍"><a href="#1、自我介绍" class="headerlink" title="1、自我介绍"></a>1、自我介绍</h5><p><code>这里建议提前做好准备，包括对自己技术栈的描述、项目的描述等等，而校园经历实则不具备任何重要性，可说可不说。重点就在于对自己技术栈的和项目的描述，因为一个好的描述方式可以起到引导面试官的作用。比如说，我的介绍里面讲到了我会grpc等微服务开发，对应于面试官的问题就是“说说你对微服务的理解、微服务是如何分块的以及在你的项目中你设计了哪些微服务？”。还有就是对与项目而言，如果条件允许的话，可以试着打听一下面试官的基本信息，一定不要撞到面试官非常擅长的领域（除非你足够强，不然会死的很惨！！！）。</code></p><h5 id="2、说说你对微服务的理解、微服务是如何分块的以及在你的项目中你设计了哪些微服务？"><a href="#2、说说你对微服务的理解、微服务是如何分块的以及在你的项目中你设计了哪些微服务？" class="headerlink" title="2、说说你对微服务的理解、微服务是如何分块的以及在你的项目中你设计了哪些微服务？"></a>2、说说你对微服务的理解、微服务是如何分块的以及在你的项目中你设计了哪些微服务？</h5><p><code>这里掌握微服务的分块理念即可，难度不大。</code></p><h5 id="3、你说你会mysql、redis的基本使用，那你从其中选择一种说一下它的特性。"><a href="#3、你说你会mysql、redis的基本使用，那你从其中选择一种说一下它的特性。" class="headerlink" title="3、你说你会mysql、redis的基本使用，那你从其中选择一种说一下它的特性。"></a>3、你说你会<code>mysql、redis</code>的基本使用，那你从其中选择一种说一下它的特性。</h5><p><code>我选的是redis，然后把redis的特性背了一遍，其中也讲到了redis作为分布式数据库的哨兵机制，结果说完之后就被追问了！！</code></p><h5 id="4、哨兵机制已经相对比较古老了，当前存在新的方案取解决，你了解吗，说一下。"><a href="#4、哨兵机制已经相对比较古老了，当前存在新的方案取解决，你了解吗，说一下。" class="headerlink" title="4、哨兵机制已经相对比较古老了，当前存在新的方案取解决，你了解吗，说一下。"></a>4、哨兵机制已经相对比较古老了，当前存在新的方案取解决，你了解吗，说一下。</h5><p><code>当然是不了解。</code></p><h5 id="5、在你的青训营项目里边儿用到了redis，说一下你是怎么使用的。"><a href="#5、在你的青训营项目里边儿用到了redis，说一下你是怎么使用的。" class="headerlink" title="5、在你的青训营项目里边儿用到了redis，说一下你是怎么使用的。"></a>5、在你的青训营项目里边儿用到了<code>redis</code>，说一下你是怎么使用的。</h5><p><code>我在项目里面使用redis的场景主要是用zset结构存储短视频的url，并使用它的排序功能按照时间戳的先后顺序进行排序，以便视频推流时可以按照先发布先推流顺序。</code></p><h5 id="6、你的zset存储结构里除了存储url之外还存储了其他内容吗？"><a href="#6、你的zset存储结构里除了存储url之外还存储了其他内容吗？" class="headerlink" title="6、你的zset存储结构里除了存储url之外还存储了其他内容吗？"></a>6、你的<code>zset</code>存储结构里除了存储<code>url</code>之外还存储了其他内容吗？</h5><p><code>没有，其他内容诸如评论内容等按理说也应该存储在redis中，但是由于时间问题，最终只做了url的。</code></p><h5 id="7、该项目的数据库表你是如何设计的？"><a href="#7、该项目的数据库表你是如何设计的？" class="headerlink" title="7、该项目的数据库表你是如何设计的？"></a>7、该项目的数据库表你是如何设计的？</h5><p><code>阿巴阿巴阿巴说一堆，这个结合自己实际项目即可。</code></p><h5 id="8、你了解MySQL的哪些特性？"><a href="#8、你了解MySQL的哪些特性？" class="headerlink" title="8、你了解MySQL的哪些特性？"></a>8、你了解<code>MySQL</code>的哪些特性？</h5><p><code>1、原子性：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么 全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性；</code></p><p><code>2、一致性：数据库总是从一个一致性的状态转换到另一个一致性的状态。（在前面的例子中，一致性确保了，即 使在转账过程中系统崩溃，支票账户中也不会损失200美元，因为事务最终没有提交，所以事务中所做 的修改也不会保存到数据库中。）；（这里我回答的时候居然忘了一致性的表述方式，太紧张了~~~）</code></p><p><code>3、隔离性：通常来说，一个事务所做的修改操作在提交事务之前，对于其他事务来说是不可见的。（在前面的例 子中，当执行完第三条语句、第四条语句还未开始时，此时有另外的一个账户汇总程序开始运行，则 其看到支票帐户的余额并没有被减去200美元。）。</code></p><p><code>4、持久性：一旦事务提交，则其所做的修改会永久保存到数据库。</code></p><h5 id="9、说一下MySQL的存储隔离级别。"><a href="#9、说一下MySQL的存储隔离级别。" class="headerlink" title="9、说一下MySQL的存储隔离级别。"></a>9、说一下<code>MySQL</code>的存储隔离级别。</h5><p><code>1、未提交读：事务中发生了修改，即使没有提交，其他事务也是可见的，比如对于一个数A原来50修改为100，但是我还没有提交修改，另一个事务看到这个修改，而这个时候原事务发生了回滚，这时候A还是50，但是另一个事务看到的A是100.可能会导致脏读、幻读或不可重复读；</code></p><p><code>2、提交读：对于一个事务从开始直到提交之前，所做的任何修改是其他事务不可见的，举例就是对于一个数A原来是50，然后提交修改成100，这个时候另一个事务在A提交修改之前，读取的A是50，刚读取完，A就被修改成100，这个时候另一个事务再进行读取发现A就突然变成100了；可以阻止脏读，但是幻读或不可重复读仍有可能发生；</code></p><p><code>3、重复读：就是对一个记录读取多次的记录是相同的，比如对于一个数A读取的话一直是A，前后两次读取的A是一致的；可以阻止脏读和不可重复读，但幻读仍有可能发生；</code></p><p><code>4、可串行化读：在并发情况下，和串行化的读取的结果是一致的，没有什么不同，比 如不会发生脏读和幻读；该级别可以防止脏读、不可重复读以及幻读。</code></p><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center"><code>Read_Uncommitted 未提交读</code></td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center"><code>Read_Committed 提交读</code></td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center"><code>Repeatable_Read 重复读</code></td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center"><code>Serializable 可串行读</code></td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><h5 id="10、项目里用到了敏感词过滤，你使用elasticsearch做的还是说直接使用深度学习里的自然语言处理做的？"><a href="#10、项目里用到了敏感词过滤，你使用elasticsearch做的还是说直接使用深度学习里的自然语言处理做的？" class="headerlink" title="10、项目里用到了敏感词过滤，你使用elasticsearch做的还是说直接使用深度学习里的自然语言处理做的？"></a>10、项目里用到了敏感词过滤，你使用<code>elasticsearch</code>做的还是说直接使用深度学习里的自然语言处理做的？</h5><p><code>我说用的是elasticsearch做的，然后说了一下流程。（其实我是用敏感词库识别做的，但感觉太low了上不了台面，正好知道es，就编了一下）</code></p><h5 id="11、你知道数据库的隔离级别是通过什么做的吗？"><a href="#11、你知道数据库的隔离级别是通过什么做的吗？" class="headerlink" title="11、你知道数据库的隔离级别是通过什么做的吗？"></a>11、你知道数据库的隔离级别是通过什么做的吗？</h5><p><code>问到盲区了，确实不知道</code></p><h5 id="12、你知道MVCC吗？"><a href="#12、你知道MVCC吗？" class="headerlink" title="12、你知道MVCC吗？"></a>12、你知道<code>MVCC</code>吗？</h5><p><code>MVCC也就是多版本并发控制......</code></p><h5 id="13、反问环节"><a href="#13、反问环节" class="headerlink" title="13、反问环节"></a>13、反问环节</h5><p><code>这个环节自主性较强，但是最好不要不问。可以问一些部门相关的业务问题，以展示你对他们公司的在意程度。</code></p>]]></content>
    
    
    <categories>
      
      <category>求职经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暑期实习--面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>北京信安go后端开发实习--笔试</title>
    <link href="/2024/06/20/%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0-%E7%AC%94%E8%AF%95/"/>
    <url>/2024/06/20/%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0-%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="北京信安go后端笔试题目"><a href="#北京信安go后端笔试题目" class="headerlink" title="北京信安go后端笔试题目"></a>北京信安go后端笔试题目</h2><h4 id="此次笔试一共7道题目，整体难度偏易，涉及到数据库、计算机网络、测试相关、系统原理、数据结构与算法"><a href="#此次笔试一共7道题目，整体难度偏易，涉及到数据库、计算机网络、测试相关、系统原理、数据结构与算法" class="headerlink" title="此次笔试一共7道题目，整体难度偏易，涉及到数据库、计算机网络、测试相关、系统原理、数据结构与算法"></a>此次笔试一共7道题目，整体难度偏易，涉及到<code>数据库</code>、<code>计算机网络</code>、<code>测试相关</code>、<code>系统原理</code>、<code>数据结构与算法</code></h4><h5 id="1、简述静态测试与动态测试的区别"><a href="#1、简述静态测试与动态测试的区别" class="headerlink" title="1、简述静态测试与动态测试的区别"></a>1、简述静态测试与动态测试的区别</h5><p><code>1、测试部分的不同：静态测试是指测试不运行的部分：只是检查和审阅,如规范测试、软件模型测试、文档测试等。动态测试是通常意义上的测试，也就是运行和使用软件。</code></p><p><code>2、测试方式不同：静态测试，通过评审文档、阅读代码等方式测试软件称为静态测试，通过运行程序测试软件称为动态测试。</code></p><p><code>3、测试方法不同：静态测试是指不用执行程序的测试，它主要采取方案—代码走查、技术评审、代码审查的方法对软件产品进行测试。动态测试主要通过构造测试实例、执行程序、分析程序的输出结果这三种方法来对软件进行测试。</code></p><p> <code>静态测试主要包括：（1）代码检查：代码会审、代码走查、桌面检查；（2）静态结构分析；（3）代码质量度量。</code><br><code> 动态测试主要包括：（1）黑盒测试：又称功能测试。这种方法把被测软件看成黑盒，在不考虑软件内部结构和特性的情况下测试   软件的外部特性。（2）白盒测试：又称结构测试。这种方法把被测软件看成白盒，根据程序的内部结构和逻辑设计来设计测试实   例，对程序的路径和过程进行测试。</code></p><h5 id="2、简述POST请求与GET请求的区别"><a href="#2、简述POST请求与GET请求的区别" class="headerlink" title="2、简述POST请求与GET请求的区别"></a>2、简述POST请求与GET请求的区别</h5><p><code>1、get请求一般是去取获取数据（其实也可以提交，但常见的是获取数据）；post请求一般是去提交数据。</code></p><p><code>2、get因为参数会放在url中，所以隐私性，安全性较差，请求的数据长度是有限制的，不同的浏览器和服务器不同，一般限制在 2~8K 之间，更加常见的是 1k 以内；post请求是没有的长度限制，请求数据是放在body中；</code></p><p><code>3、get请求刷新服务器或者回退没有影响，post请求回退时会重新提交数据请求。</code></p><p><code>4、get请求可以被缓存，post请求不会被缓存。</code></p><p><code>5、get请求会被保存在浏览器历史记录当中，post不会。get请求可以被收藏为书签，因为参数就是url中，但post不能。它的参数不在url中。</code></p><p><code>6、get请求只能进行url编码（appliacation-x-www-form-urlencoded）,post请求支持多种（multipart/form-data等）。</code></p><h5 id="3、简述数据中事务的特点（特性）"><a href="#3、简述数据中事务的特点（特性）" class="headerlink" title="3、简述数据中事务的特点（特性）"></a>3、简述数据中事务的特点（特性）</h5><p><code>事务的四大特性：1、原子性(Atomicity)；2、一致性(Consistency)；3、隔离性(Isolation)；4、持久性(Durability)</code></p><p><code> 原子性:</code></p><p><code>一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么 全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性</code></p><p><code> 一致性:</code></p><p><code>数据库总是从一个一致性的状态转换到另一个一致性的状态。（在前面的例子中，一致性确保了，即 使在转账过程中系统崩溃，支票账户中也不会损失200美元，因为事务最终没有提交，所以事务中所做 的修改也不会保存到数据库中。）</code></p><p><code> 隔离性:</code><br><code>通常来说，一个事务所做的修改操作在提交事务之前，对于其他事务来说是不可见的。（在前面的例 子中，当执行完第三条语句、第四条语句还未开始时，此时有另外的一个账户汇总程序开始运行，则 其看到支票帐户的余额并没有被减去200美元。）</code></p><p> <code>持久性:</code><br><code>一旦事务提交，则其所做的修改会永久保存到数据库。</code></p><h5 id="4、现在有一个表结构如下：表明是orders，字段为：name（姓名）type为varchar，age（年龄）type为int，birthday（出生日期）type为datetime，status（是否注册的状态）type为varchar。找出出生日期在2022-01-01之后的并且注册状态是已注册的用户信息，并且按照时间顺序从前往后排序，写出对应的SQL语句"><a href="#4、现在有一个表结构如下：表明是orders，字段为：name（姓名）type为varchar，age（年龄）type为int，birthday（出生日期）type为datetime，status（是否注册的状态）type为varchar。找出出生日期在2022-01-01之后的并且注册状态是已注册的用户信息，并且按照时间顺序从前往后排序，写出对应的SQL语句" class="headerlink" title="4、现在有一个表结构如下：表明是orders，字段为：name（姓名）type为varchar，age（年龄）type为int，birthday（出生日期）type为datetime，status（是否注册的状态）type为varchar。找出出生日期在2022-01-01之后的并且注册状态是已注册的用户信息，并且按照时间顺序从前往后排序，写出对应的SQL语句"></a>4、现在有一个表结构如下：表明是<code>orders</code>，字段为：<code>name</code>（姓名）<code>type</code>为<code>varchar</code>，<code>age</code>（年龄）<code>type</code>为<code>int</code>，<code>birthday</code>（出生日期）<code>type</code>为<code>datetime</code>，<code>status</code>（是否注册的状态）<code>type</code>为<code>varchar</code>。找出出生日期在<code>2022-01-01</code>之后的并且注册状态是已注册的用户信息，并且按照时间顺序从前往后排序，写出对应的<code>SQL</code>语句</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> (birthday <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;2022-01-01&#x27;</span> <span class="hljs-keyword">AND</span> status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;已注册&#x27;</span>) <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> birthday <span class="hljs-keyword">ASC</span>;<br></code></pre></td></tr></table></figure><h5 id="5、简述进程与协程的区别，并说明它们是如何通信的"><a href="#5、简述进程与协程的区别，并说明它们是如何通信的" class="headerlink" title="5、简述进程与协程的区别，并说明它们是如何通信的"></a>5、简述进程与协程的区别，并说明它们是如何通信的</h5><p><code>1、进程是资源分配和拥有的基本单位，而线程是程序执行的基本单位； 2、进程拥有更多的资源，包括cpu资源、内存资源、文件资源和字柄，而线程拥有的资源包括程序计数器、寄存器、栈和状态字； 3、对于并发性而言，不同进程之间切换实现并发，各自占有CPU实现并行；而一个进程内部的多个线程并发执行； 4、而在通信方面，进程间通信需要借助操作系统；而线程间可以直接读取进程数据段（如全局变量）来进行通信。</code></p><h5 id="6、说明下面程序运行的结果"><a href="#6、说明下面程序运行的结果" class="headerlink" title="6、说明下面程序运行的结果"></a>6、说明下面程序运行的结果</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tmp</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> *tmp(i<span class="hljs-number">-1</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    fmt.Println(tmp(<span class="hljs-number">5</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p><code>你是否会认为这个结果为1？？？但实际上，它的执行结果应该是：执行错误！！！</code></p><p><code>错误原因是*tmp(i-1)并不是一个int类型的，而对于tmp函数而言，所传入的参数必须是int类型的，因此这里会发生错误！</code></p><h5 id="7、算法题：现在给定一个数组nums，它里面的值由1-100里的数随机组成（即并不一定所有数都包含），nums的长度为0-10-32，现在需要判断nums中不包含哪些1-100的数字，并将其输出"><a href="#7、算法题：现在给定一个数组nums，它里面的值由1-100里的数随机组成（即并不一定所有数都包含），nums的长度为0-10-32，现在需要判断nums中不包含哪些1-100的数字，并将其输出" class="headerlink" title="7、算法题：现在给定一个数组nums，它里面的值由1-100里的数随机组成（即并不一定所有数都包含），nums的长度为0-10^32，现在需要判断nums中不包含哪些1-100的数字，并将其输出"></a>7、算法题：现在给定一个数组<code>nums</code>，它里面的值由<code>1-100</code>里的数随机组成（即并不一定所有数都包含），<code>nums</code>的长度为<code>0-10^32</code>，现在需要判断<code>nums</code>中不包含哪些<code>1-100</code>的数字，并将其输出</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <br>    tmpMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">100</span>)<br>    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> _, ok := tmpMap[v]; !ok &#123;<br>            tmpMap[v] = k<br>        &#125;<br>    &#125;<br>    <br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(tmpMap) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> res<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">100</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span> _, ok := tmp[i]; !ok &#123;<br>            res = <span class="hljs-built_in">append</span>(res, i)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>求职经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常实习--笔试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
